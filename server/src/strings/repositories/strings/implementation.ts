import assert from 'node:assert';

import { eq, sql } from 'drizzle-orm';

import { strings, translations } from '../../../db/schema';
import type StringModel from '../../models/string';
import { newString, type IString } from '../../models/string';
import type { StringsRepository, TranslationEntry } from './types';
import type { HonoContext } from '../../../context';
import { getSession } from '../../../context/session';
import { getDrizzle } from '../../../context/database';
import { getLogger } from '../../../context/logging';
import { StringKeyAlreadyExists } from '../../exceptions';
import type { SessionResponse } from '../../../auth';

class StringsRepositoryImpl implements StringsRepository {
  private readonly context: HonoContext;

  constructor(params: { context: HonoContext }) {
    this.context = params.context;
  }

  createString = async (payload: Omit<IString, 'id'>): Promise<StringModel> => {
    this.getSession(); // Verify user is authenticated
    const string = newString({ ...payload, id: null });
    assert(string.id, 'ID should have gotten generated by the constructor of StringModel');

    const result = await getDrizzle(this.context).insert(strings).values(string).onConflictDoNothing();
    if (result.rowCount === 0) {
      getLogger(this.context).error('String key already exists for project', {
        string_key: payload.key,
        project_id: payload.projectId,
      });
      throw new StringKeyAlreadyExists(this.context);
    }

    return string;
  };

  list = async (projectId: string): Promise<StringModel[]> => {
    this.getSession(); // Verify user is authenticated
    const projectStrings = await getDrizzle(this.context).query.strings.findMany({
      where: () => eq(strings.projectId, projectId),
    });

    return projectStrings.map(newString);
  };

  read = async (id: string): Promise<StringModel | null> => {
    this.getSession(); // Verify user is authenticated
    const string = await getDrizzle(this.context).query.strings.findFirst({
      where: () => eq(strings.id, id),
    });
    if (string == null) {
      return null;
    }

    return newString(string);
  };

  getTranslationsForLocale = async (
    projectId: string,
    locale: string,
  ): Promise<Array<{ key: string; value: string | null; context: string | null }>> => {
    const result = await getDrizzle(this.context)
      .select({
        key: strings.key,
        value: translations.value,
        context: strings.context,
      })
      .from(strings)
      .leftJoin(translations, sql`${translations.stringId} = ${strings.id} AND ${translations.locale} = ${locale}`)
      .where(eq(strings.projectId, projectId))
      .orderBy(strings.key);

    return result;
  };

  upsertTranslations = async (projectId: string, entries: TranslationEntry[]): Promise<{ updatedCount: number }> => {
    this.getSession(); // Verify user is authenticated

    const drizzle = getDrizzle(this.context);
    const keys = entries.map(e => e.key);
    const now = new Date();

    // Get existing strings for this project
    const existingStrings = await drizzle.query.strings.findMany({
      where: () => sql`${strings.projectId} = ${projectId} AND ${strings.key} IN ${keys}`,
    });

    const existingKeyMap = new Map(existingStrings.map(s => [s.key, s.id]));

    // Prepare strings to insert (new ones) and update (existing ones with context changes)
    const stringsToInsert: Array<{
      id: string;
      key: string;
      context: string | null;
      projectId: string;
      createdAt: Date;
      updatedAt: Date;
    }> = [];
    const stringsToUpdate: Array<{ id: string; context: string | null }> = [];
    const keyToIdMap = new Map<string, string>();

    for (const entry of entries) {
      const existingId = existingKeyMap.get(entry.key);
      if (existingId) {
        keyToIdMap.set(entry.key, existingId);
        if (entry.context !== undefined) {
          stringsToUpdate.push({ id: existingId, context: entry.context ?? null });
        }
      } else {
        const newId = Bun.randomUUIDv7();
        keyToIdMap.set(entry.key, newId);
        stringsToInsert.push({
          id: newId,
          key: entry.key,
          context: entry.context ?? null,
          projectId,
          createdAt: now,
          updatedAt: now,
        });
      }
    }

    // Insert new strings in batch
    if (stringsToInsert.length > 0) {
      await drizzle.insert(strings).values(stringsToInsert);
    }

    // Update existing strings context in batch
    for (const update of stringsToUpdate) {
      await drizzle.update(strings).set({ context: update.context, updatedAt: now }).where(eq(strings.id, update.id));
    }

    // Prepare translations to upsert
    const translationsToUpsert: Array<{
      id: string;
      stringId: string;
      locale: string;
      value: string;
      createdAt: Date;
      updatedAt: Date;
    }> = [];

    for (const entry of entries) {
      const stringId = keyToIdMap.get(entry.key);
      assert(stringId, 'String ID should exist at this point');

      for (const [locale, value] of Object.entries(entry.translations)) {
        translationsToUpsert.push({
          id: Bun.randomUUIDv7(),
          stringId,
          locale,
          value,
          createdAt: now,
          updatedAt: now,
        });
      }
    }

    // Upsert translations in batch
    if (translationsToUpsert.length > 0) {
      await drizzle
        .insert(translations)
        .values(translationsToUpsert)
        .onConflictDoUpdate({
          target: [translations.stringId, translations.locale],
          set: {
            value: sql`excluded.value`,
            updatedAt: sql`excluded.updated_at`,
          },
        });
    }

    return { updatedCount: translationsToUpsert.length };
  };

  private getSession = (): SessionResponse => {
    const session = getSession(this.context);
    assert(session != null, 'This function should have been called with an authorized request');

    return session;
  };
}

export default StringsRepositoryImpl;
